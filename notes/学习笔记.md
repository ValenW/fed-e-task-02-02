1. # 模块化

   ## 演变过程

   1. 文件划分

      - 完全依赖约定

      - 污染全局作用域
      - 可以被修改

      - 命名冲突
      - 无法管理依赖关系

   2. 命名空间

      - 将模块包裹为全局对象, 减少命名冲突
      - 依然会被访问修改

   3. IIFE, 立即执行函数

      - 将模块放到函数私有作用域中并立即执行函数
      - 在闭包中挂载到全局变量中
      - 可以在函数参数中传递依赖, 更显式地表现依赖关系

   以上都是根据约定制定的, 而且每个模块都是使用script标签在HTML中引用, 不好进行依赖的管理和更新. 所以我们需要一套**模块化规范**和**模块加载器**

   ### AMD(Asynchronous Module Definition)

   Require.js, 实现了AMD的模块加载器

   ```js
   define('moduleName', ['requireModule1', 'requireModule2'], function(m1, m2) { // 定义模块
     return {
       exportMethod1: ...,
       exportValue1: ...
     }
   })
   require(['module1'], function (m1) {...}) // 用于加载模块
   ```

   - 目前绝大多数三方库都支持AMD标准
   - 使用起来相对复杂
   - 模块js文件请求频繁

   ### Sea.js+CMD

   淘宝推出的重复轮子, 和Require.js+AMD基本一致, 目的是尽可能兼容commonjs规范

   ## 模块化规范

   ### CommonJS

   **Node**提出和使用, 以**同步模式加载**模块,在启动时就加载所有模块

   - 一个文件一个模块
   - 每个模块单独作用域
   - 通过module.exports导出成员
   - 通过require函数载入模块

   ### ES Modules

   在ES6中定义, 历史不久, 存在各种环境兼容问题. 在webpack等打包工具出现后才逐渐普及

   在语言层面实现模块化, 更完善

   #### 基本特性

   `<script type="module" ... />`加载脚本

   1. 自动采用严格模式, 忽略`use strict`
   2. 每个module运行在单独的私有定义域中
   3. 通过CORS方式请求外部js模块, 需要源地址支持CORS
   4. ESM标签会自动延迟执行脚本, 等待网页渲染完成后执行模块代码

   #### 导出

   ```js
   export var name = xxx;
   import { name } from 'module.js'
   // 并非导出对象字面量, 是导出的固定用法, export 不能导出字面量
   export { name, method as name2, module as default, ...}
   // 导出字面量
   export default { name, age }
   import module, { default as module2, name2 } from 'module.js'
   ```

   **导出的是只读的引用**, 并非拷贝赋值, 所以模块内更改会影响模块外, 但不能在模块外修改导出成员的值

   #### 导入

   1. 原生ES Modules导入时必须填写完整路径, 不能省略`.js`, 或是 `/index.js`
   2. 当前目录下也不能省略`./`, 否则会被认为是第三方模块
   3. 可以使用/开头的相对路径, 也可以使用url路径
   4. `import {} from '...'`是只执行模块而不导入成员, 简写为`import '...'`
   5. `import * as mod form '...'`当需要导入太多时
   6. 提供异步加载函数`import`, 支持动态加载模块
      1. `import('./module.js').then(m => log(m))`
   7. `import xxx from 'xxx'`是导入默认成员并重命名为xxx
   8. 聚合导出, `export { default as m1, m1Method } from './m1.js'`

   #### Polyfill

   使用基于babel的[browser-es-module-loader](https://github.com/ModuleLoader/browser-es-module-loader), 对于ie还需要兼容[Promise](https://github.com/taylorhakes/promise-polyfill)

   npm包可以通过unpkg.com解包以直接script引用

   另外加上`nomodule`属性, 这样在支持ES Module的浏览器下就不会引入, 不会出现模块被执行两遍的情况

   ```js
   <script nomodule src="https://unpkg.com/promise-polyfill@8.1.3/dist/polyfill.min.js" />
   <script nomodule src="https://unpkg.com/browser-es-module-loader@0.4.1/dist/babel-browser-build.js" />
   <script nomodule src="https://unpkg.com/browser-es-module-loader@0.4.1/dist/browser-es-module-loader.js" />
   ```

   但这样都是在运行阶段动态执行脚本, 效率非常差

   生产环境应该预先编译成能在各种环境工作的代码

   #### node支持情况

   node在8.5之后就加入了对esm的支持

   1. 需要将文件名从`.js`改到`.mjs`
   2. `node --experimental-modules xx.mjs`
   3. 系统内置成员可以部分导入`import { writeFileSync } from 'fs'`
   4. 第三份模块只能通过默认成员导入
      1. `import { camelCase } from 'lodash'` ×
      2. `import _ from 'lodash'` √

   ##### ESM和commonJS交互

   - ESM中可以载入commonJS模块

     - import 不是解构成员
     - commonJS只会导出默认成员, 不能在ESM直接提取成员

   - commonJS中不能载入ESM

   - ESM中不能使用commonJS模块**内置成员**

     这些是commonjs包装函数的参数传递的, 其实是伪全局对象

     - require, 加载模块函数

     - module, 模块对象

     - exports, 导出对象别名

     - __filename, 当前文件绝对路径

     - __dirname, 当前文件所在目录

       ESM中可以通过其他方式得到

       ```js
       import { fileURLToPath } from 'url'
       import { dirname } from 'path'
       __filename = fileURLToPath(import.meta.url)
       __dirname = dirname(__filename)
       ```


   ##### 12.10.0之后Node增强了对ESM的支持

   - `package.json`中增加`"type": "module"`, 项目默认使用ESM加载, 不需要.mjs后缀
   - 而此时commonjs规范需要使用.cjs后缀

   ##### babel支持低版本node中使用ESM

   - `@babel/node, /core /preset-env`
   - babel核心代码不会转换代码, 需要每个特性对应的插件进行转换
     - `yarn babel-node module.js --presets=@babel/preset-env`
     - 也可以在`.babelrc`文件中设置`"presets": ["@babel/preset-env"]`
   - 单单转换commonjs和ESM的话, 可以使用`/plugin-modules-commonjs`而不需`preset`
     - `"plugins": ["@babel/plugin-modules-commonjs"]`

   ## 模块化存在的问题

   - 环境兼容
   - 模块文件过多导致网络请求频繁
   - 其他文件也需要模块化(css等)

   所以我们需要的工具应该

   - 编译代码
   - 打包js代码
   - 支持不同类型资源的打包

   对前端整体的模块化, 并不单单指JavaScript模块化

   # Webpack打包

   - 通过loader对代码进行编译转化
   - 支持对代码进行拆分
   - 支持模块化载入任何类型的文件

   4.0后支持零配置, 默认从`src/index.js`开始打包, 输出为`dist/main.js`

   ## webpack.config.js

   运行在node下, 需要使用commonjs

   ```js
   const path = require('path')
   module.exports = {
       entry: './src/main.js',
       // output path 必须使用绝对路径
       output: { filename: 'bundle.js', path: path.join(__dirname, 'putput') }
   }
   ```

   ## [运行模式](https://webpack.js.org/configuration/mode/)

   运行时通过`--mode`指定, 或者config中`mode: 'xxx'`指定:

   1. production, 包含一系列优化, 包括压缩
   2. development, 优化编译速度, 加入调试辅助代码
   3. none, 不做任何额外处理

   ## 打包结果

   1. 一个立即执行函数`webpackBootstrap`, 参数是modules
      1. 加载过模块的缓存数组
      2. 定义require函数
         1. 如果有cache用cache
         2. 初始化module
         3. 执行模块函数, 传入模块数组, require函数等方便模块导入导出成员
         4. 将module加上ESmodule, loaded等标记
         5. 返回module.exports对象
      3. 在require函数上挂载其他数据和工具函数, 如上面的模块缓存数组
      4. 调用require函数加载入口模块
   2. 实参是src中的各个模块形成的函数, 模块内容被包裹在函数作用域内

   ## 加载器 Loader

   1. 编译转换类

      css, 将css代码转换为js模块加入bundle.js中

   2. 文件操作

      file-loader, 将文件复制到输出路径, 并导出访问路径

   3. 代码检查

      统一代码风格, 检查是否通过, 一般不会修改导出的代码

   ### CSS加载器

   内部loader只能处理js, 不同类型的文件打包需要配置对应的**loader**, . 同时需要配置对应的rules

   ```js
   entry: './src/main.css',
   module: {
     rules: [
       // css-loader只会把css代码打包成一个js模块, push到一个数组中, 但并不会使用这些模块
       // style-loader负责使用style标签将css挂载到element上
       // use数组中的loader是从后往前执行的
       { test: /.css$/, use: ['style-loader', 'css-loader'] },
     ]
   }
   ```

   #### 作为模块在js中导入

   webpack的entry通常都是js文件

   可以在`main.js/header.js`中直接`import './main.css', import 'header.css'`等

   **webpack思想是前端应用由js驱动, 应该根据代码的需要动态导入资源**, 这样逻辑合理, 而且能保证上线资源不缺失且必要

   ### 文件资源加载器

   ```js
   // config.js
   {
     output: { publicPath: 'dist/' } // 默认是项目根目录, 需要根据path修改
     module: { rules: { test: /.png$/, use: 'file-loader' } // 会将文件复制到output根目录, 然后将拷贝路径作为module的返回值
   }
   // main.js
   import icon from './icon.png' // 编译后会变成导入文件路径, publicPath(__webpack_require__.p) + fileName
   ```

   编译后会把文件放在项目根目录下, 且import的会变成文件的路径, 

   #### url加载器

   data urls的文本就包含了文件内容, 不需要从服务端请求 

   `data:[<mediatype>][;base64],<data>`, 如`data:text/html;charset=UTF-8,<h1>html context</h1>`

   将`file-loader`修改为`url-loader`, 就不会复制文件, 而是会编译为data url并导出, 适合打包体积小的文件

   ```js
   use: {
     loader: 'url-loader',
     options: {
       // 最佳实践, 超过10KB的仍会使用file-loader, 不需要单独配置, 但需要安装file-loader
       limit: 10 * 1024 // 10 KB
   }}
   ```

   ### ES6 loader

   webpack需要支持导入导出, 所以自带`import/export`支持, 但其他ES6特性还是需要loader编译

   ```js
   rules: [{
     test: /.js$/,
     use: {
       loader: 'babel-loader',
       options: { presets: ['@babel/preset-env'] }
   }}]
   ```

   ## 加载方式

   基本代码中需要引用资源的地方都会被处理, 所以webpack可以实现整个前端项目的模块化

   - ESM import/export

   - CommonJS

     ```js
     const m = require('./header.js').default // 获取ESM的默认导出
     const icon = require('./icon.png')
     require('./main.css')
     ```

   - AMD的define/require

     ```js
     define([m1.js, m2.js], (m1, m2) => ...module code)
     require([m1.js, m2.js], (m1, m2) => ...)
     ```

   - css中的@import指令和url函数

     ```css
     @import url('reset.css');
     /* 会触发css-loader, 将引入的css文件加载进bundle.js */
     background-color: url(background.png)
     /* css-loader编译时会触发对应的资源加载器, 这里是url-loader(/.png$/) */
     ```

   - HTML中的src属性

     ```js
     // js
     import footHTML from './footer.html' // HTML默认导出是HTML字符串
     document.write(footerHTML)
     // rules
     {
       test: /.html$/,
       use: {
         loader: 'html-loader',
         options: {
           attrs: ['img:src', 'a:href'] // 默认只会编译img中的src属性
     }}}
     ```

   ### 核心工作原理

   1. 从打包入口(通常js)开始, 解析推断其依赖的资源模块, 形成一棵依赖树
   2. 递归依赖树, 找到资源文件, 并根据rule配置使用对应loader加载
   3. 将加载结果放入bundle.js中, 从而得到整个项目的打包

   所以loader是webpack的核心机制

   ## loader机制

   loader实现资源加载功能, 相当于一段管道, 最后输出必须是**js代码**

   ```js
   // config.js
   rules: [{ test: /.md$/, use: './markedown-loader.js' }]
   // markdown-loader.js
   module.exports = source => { // source是匹配文件的文本内容
       // 最后一个loader必须返回合理的js代码
       // 使用json.stringify保留换行, 引号, 空格等
       return `export default ${JSON.stringify(markerd(source))}`
   }
   // 或者使用多个loader, 最后使用html-loader导出js化的HTML代码
   rules: [{ test: /.md$/, use: ['html-loader', './markedown-loader.js'] }]
   module.exports = scource => return markerd(source)
   ```

   ## plugin机制

   plugin解决其他自动化功能, 如拷贝, 压缩, 清除等

   ### clean-webpack-plugin

   自动清除输出目录

   ```js
   // config.js
   const { CleanWebpackPlugin } = require('clean-webpack-plugin')
   module.exports = {
     ...,
     plugins: [
       new CleanWebpackPlugin()
     ]
   }
   ```

   ### html-webpack-plugin

   自动生成引用`bundle.js`的HTML文件

   ```js
   const HtmlWebpackPlugin = require('html-webpack-plugin')
   module.exports = {
     output: {
       filename: 'bundle.js',
       // 指定输出目录, 必须绝对路径
       path: path.join(__dirname, 'dist'),
       // 打包后资源的访问路径公共部分, 用于拼接资源路径, 如 publicPath + 'xxx.js'
       // 使用html-plugin后HTML放在dist目录下, 故不需要设置
       // publicPath: 'dist'
     },
     plugins: [ ...,
       // 每个实例生成一个HTML文件
       new HtmlWebpackPlugin({
         title: 'plugin title',
         meta: { viewport: 'width=divice-width' },
         template: './src/index.html'}),
       new HtmlWebpackPlugin({ filename: 'about.html', ... })
   ]}
   // index.html
   ...
     <h1> <%= htmlWebpackPlugin.options.title %> </h1>
   ```

   ### copy-webpack-plugin

   ```js
   const CopyWebpackPlugin = require('copy-webpack-plugin')
   module.exports = { ..., plugins: [ new CopyWebpackPlugin(['public/**'])]}
   ```

   ### 开发plugin

   使用钩子模式, webpack提供很细节的各个阶段的[钩子](https://webpack.docschina.org/api/compiler-hooks/#%E9%92%A9%E5%AD%90)

   ```js
   class RemoveJsCommentPlugin {
     apply (compiler) {
       compiler.hooks.emit.tap('RemoveJsCommentPlugin', compilation => {
         // compilatoin, 此次打包的上下文
         for (const name in compilation.assets) {
           if (name.endsWith('.js')) {
             const contents = compilation.assets[name].source() // 得到文件内容
             const removed = contents.replace(/\/\*\*+\*\//g, '')
             compilation.assets[name] = {
               source: () => removed,
               size: () => removed.length // webpack规定必须方法
    }}}})}}
   ```

   ## 开发体验

   ### 提供自动编译, 热更新

   `yarn webpack --watch`, 启动后会监视文件, 并自动重新编译打包

   ### server服务, 包括请求处理, 文件访问等

   `browser-sync dist --files "**/*"`另起一个服务, 自动监听dist文件夹变化并刷新

   1. 需要起两个工具, 不方便
   2. 效率下降, webpack和serve通过磁盘交互, 一次更新就有一次磁盘读写

   #### webpack-dev-server

   ```js
   yarn add webpack-dev-server --dev
   yarn webpack-dev-server (--open)
   ```

   1. 自动使用webpack打包
   2. 启动server运行打包结果
   3. 监听文件变化并自动重新打包刷新
   4. 打包结果存放在内存中, 不会写入磁盘, 速度快

   默认只会serve通过webpack打包的文件, 没经过webpack的静态资源需要添加配置

   ```
   devServer: {
     // contentBase为serve额外指定serve目录
     contentBase: ['./public'] // 开发时不会执行copy任务
   }
   ```

   ##### 代理API

   开发时需要后端api, 但域名不一样且不开启CORS, 此时可以使用serve代理

   ```js
   devServer: {
     proxy: {
       '/api': {
         // http://localhost:8080/api/users => https://api.github.com/api/users
         target: 'https://api.github.com',
         // https://api.github.com/api/users => https://api.github.com/users
         pathRewrite: { '^/api': '' },
         // 更改HTML请求头中的host字段为代理后的主机名, 指定服务器域名
         // 用于运行多服务的虚拟主机分发到正确服务端口
         changeOrigin: true
   }}}
   ```

   ### Source Map

   映射源代码和转换后代码映射关系, 方便调试定位bug

   - version: sourceMap标准版本

   - sources: [...], 源文件文件名

   - names: 简短字符和源代码变量名映射

   - mappings: bas64字符串, 记录两个文件映射关系

     `";;AAAA,IAAM,MAAM,GAAG,SAAT,MAAM,CAAI,CAAC;SAAK,CAAC,GAAG,CAAC;CAAA,CAAC"`

     - `;,`分别分割行和列

     - 每组字母是经过base64转换的VLQ编码, 代表每个segment的原位置定位

       - 第一位[0]：代表在转换后文件的第几列（相对于前一个position的相对位置）

         第二位[1]：代表源文件在sources里对应的文件序列// 上述mapping的第二位都是A，因为原文件都是第0位

         第三位[2]:  代表在源文件的第几行 // 上述mapping的第三位都是A，因为源文件都在也只有第1行

         第四位[3]：代表在转换后文件的第几列（相对于前一个position的相对位置）

         第五位[4]：代表属于names里的哪一个变量

   min.js 最后可以加上 `//# sourceMappingURL=jquery.map.js`,这样浏览器会自动请求map文件并映射, 方便调试

   #### webpack配置

   支持[多种模式](https://webpack.js.org/configuration/devtool/#devtool)的sourceMap配置

   ```js
   module.exports = { devtool: 'source-map' } // 原始模式
   
   // webpack.config可以导出数组, 每个item都是一个任务, 方便对比不同配置
   const allDevMode = ['eval', 'cheap-eval-source-map', 'cheap-module-eval-source-map', ...]
   module.exports = allDevMode.map(item => ({
   	devtool: item,
   	mode: 'none', // 确保webpack不做额外处理
   	entry: './src/index.js',
   	output: { finename: `js/${item}.js` },
   	module: { rules: [babel...] },
   }))
   ```

   - eval
     - 通过**eval函数执行**打包后的模块代码, 并在最后通过sourceURL定位源代码文件, 只能定位文件
   - eval-source-map
     - 在eval基础上生成sourcemap, 可**定位具体行列**
   - cheap-eval-source-map
     - **只定位到行**, 没有列信息
   - cheap-module-eval-source-map
     - 能**定位到源代码**, 以上只能定位到编译后代码
   - inline-source-map
     - sourceURL**使用dataURL**, 不用请求
   - hidden-source-map
     - 生成map文件, 但代码中**不引用map文件**, 通常用在第三方包中
   - nosources-source-map
     - **看不到源代码**, 但提供行列信息, 用于生产环境保护源代码

   #### 推荐配置

   - 开发环境, cheap-module-eval-source-map
     - 每行代码不超过80
     - 编译后代码差异大
     - 首次打包较慢, 但重写打包快
   - 生产环境, none, 不生成source-map
     - 不暴露源代码
     - 或者`nosources-source-map`

   ### HMR, Hot Module Replacement

   整个页面刷新, 对重度前端应用的调试不友好, 如编辑器调试, 刷新后输入都没了

   热替换将更改的模块实时替换到应用中,不必完全刷新页面

   - 样式文件的热更新只需要更新样式, 在loader中已经处理了, 所以可以开箱即用
   - 静态资源文件, 如图片的热替换, 只需要更新路径即可
   - js文件导出的有各种形式, 需要手动处理模块热替换的逻辑
     - 框架下的开发, 每个文件有规律, 基本集成了HMR, 不需要手动处理
   - 热替换函数中报错会导致页面刷新
     - `hot: true` => `hotOnly: true`
   - 热替换的代码在webpack打包的时候会被去掉, 不影响生产环境状态

   ```js
   webpack-dev-server --hot
   // config.js
   const webpack = require('webpack')
   module.exports = {...,
     devServer: { hot: true },
     plugins: [ new webpack.HotModuleReplacementPlugin() ]
   }
   // main.js
   import createEditor from './editor'
   import background from './back.png'
   ...
   // accept中注册过的路径, HMR才会做热替换, 否则会刷新页面
   // 检查module.hot, 兼容未使用HMR的情况
   if (module.hot) {
     module.hot.accept('./back.png', () => {
       // 图片等资源替换只需要更新路径就好, 和style一致
       img.src = background
     })
   
     let lastEditor = editor
     module.hot.accept('./editor', () => {
       console.log('editor is updated')
       document.body.removeChild(editor)
       const newEditor = createEditor()
       newEditor.innerHTML = lastEditor.innerHTML
       document.body.appendChild(newEditor)
       lastEditor = newEditor
     })
   }
   ```

   ## 不同环境代码优化

   ### 根据环境导出不同配置

   ```js
   module.exports = (env, argv) => { // env 是环境参数, argv是运行时传递的所有参数
     const baseConfig = { ... prod env config }
     if (env === 'production') {
       config.plugins = [
         ...config.plugins,
         new CleanWebpackPlugin(),
         new CopyWebpackPlugin(['public'])
     ]}
     return config
   }
   // yarn webpack --env production
   ```

   ### 每个环境对应不同配置文件

   ```js
   // webpack.common.js
   module.exports = ...commonConfig
   // webpack.prod.js
   const common = require('./webpack.common')
   const merge = require('webpack-merge')
   const { CleanWebpackPlugin } = require('clean-webpack-plugin')
   
   module.exports = merge(common, {
     mode: 'production',
     plugins: [ new CleanWebpackPlugin(), ...]
   })
   // webpack.dev.js
     ...
   ```

   ### DefinePlugin

   webpack自带插件, 用于注入全局变量, 如`process.env.NODE_ENV`

   ```js
   const webpack = require('webpack')
   module.exports = {
     mode: 'none',
     ...,
     plugins: [
       new webpack.DefinePlugin({
     		// 变量值是以js代码执行的, 传递值的话可以使用JSON.stringfy
     		API_BASE_URL: '"https://api.my.com"'
   })]}
   ```

   ### tree shaking

   在webpack中不是单一的配置选项, 而是一组功能搭配使用后的优化效果, 在**production模式下自动使用**

   使用前提是必须使用ESM模式

   ```js
   module.exports = {
     mode: 'none',
     optimization: {
       usedExports: true, // 只导出外部使用的成员
       minimize: true, // 压缩代码, 去除空行, 死代码等
       concatenateModules: true, // 尽可能将所有模块合并到一个输出函数中
     }
   }
   ```

   #### 和babel一起工作

   tree shaking必须使用esm导出, 但babel可能会将esm代码转换成commonjs, 从而使tree shaking失效

   最新版本的babel自动关闭转换为commonjs插件

   - `babel-loader/injectCaller`里`supportsStaticESM = true`
   - `preset-env/polifills/index.js`, `shouldTransfromESM`决定是否转换esm代码

   可以通过配置将babel强制开启转换esm插件

   ```js
   rules: [{
     test: /\.js$/,
     use: {
       loader: 'babel-loader',
       options: {
         presets: [
           // modules: false就可以确定不会转换ESM
           ['@babel/preset-env', { modules: 'commonjs' }]
   ]}}}]
   ```

   ### side effects

   本身和treeshaking没多大关系

   webpack可以通过标识模块是否有副作用, 为tree shacking提供更大空间

   副总用指除了导出模块外是否还有其他作用

   使用`index.js`集中导出多类文件时, 即使只用到了其中1个导出, 也会使得所有文件都被打包导出

   ```js
   // webpack.config.js
   optimization: {
     sideEffects: true, // 开启webpack side effect功能
   }
   // package.json
   "sideEffects": false // 标识项目中所有导出都没有副作用
   // 但像是css, 或者增强类型(为Number增加函数等)这些代码都是有副作用的, 可以传入数组标识哪些有副作用
   "sideEffects": [
     "./src/extend.js".
     "*.css"
   ]
   ```

   ### code split

   webpack默认将所有文件打包到一起, 但更多时候我们需要按需加载

   #### 多入口打包

   适合传统多页应用

   ```js
   // 使用数组是将多个入口打包到一个文件, 对象才是多入口打包
   entry: {
     index: './src/index.js',
     about: './src.about.js'
   },
   output: {
     filename: '[name].bundle.js' // 会被自动替换为入口名字
   },
   optimization: {
     splitChunks: {
       chunks: 'all', // 会将所有chunks的公共部分打包到一个单独的文件
   }},
   plugins: [
     new HtmlWebpackPlugin({
       title, template,
       filename: 'index.html',
       chunks: ['index'] // 指定需要的bundle
     }),
     new HtmlWebpackPlugin({
       title, template,
       filename: 'about.html',
       chunks: ['about']
   }),]
   ```

   #### 动态导入

   不需任何配置, 只要使用了ESM的动态导入语法, webpack就能自动 进行分包吗提取公共模块 和 按需加载

   ```js
   import('./index.js').then(({ default: post }) => {
     document.body.appendChild(post())
   })
   ```

   ##### 魔法注释

   webpack自动的动态模块使用的是随机文件名

   可以在动态加载时通过注释指定文件名`import(/* webpackChunkName: 'posts' */'./index.js')`

   相同name的动态模块会被webpack打包在一起

   ### 样式文件的提取

   MiniCssExtractPlugin提取css到单个文件

   最好在css文件超过150k时候考虑提取, 否则适得其反

   ```js
   const MiniCssExtractPlugin = require('mini-css-extract-plugin')
   // webpack不会自动打包插件产生的文件, 需要手动引入插件压缩
   const OptimizeCssAssetsWebpackPlugin = rquire('optimize-css-assets-webpack-plugin')
   const TerserWebpackPlugin = require('terser-webpack-plugin')
   
   rules: [{
     test: /\.css$/,
     use: [
       // 'style-loader', // 用style标签导入, 而插件是使用link标签引用
       MiniCssExtractPlugin.loader,
       'css-loader',
   ]}],
   optimization: {
     minimizer: [
       // 官方建议压缩类插件放在minimizer下, 而不是plugin下, 方便通过配置统一开启/关闭压缩功能
       new OptimizeCssAssetsWebpackPlugin(),
       // 因为是覆盖形式, webpack默认的js压缩不起效, 需要手动导入
       new TerserWebpackPlugin()
   ]}
   plugins: [..., new MiniCssExtractPlugin(),]
   ```

   ### 输出文件名hash

   确保文件变化后文件名变化, 客户能使用最新的代码

   - hash, 项目级别hash
   - chunkhash, 每个chunk独立hash
   - contenthash, 每个文件独立hash, 输出文件变化才改变文件名
   - 之后可跟`:number`指定hash长度, 如`contenthash:8`

   ```js
   // output和绝大多数插件都支持filename属性设置, 并且有3种hash模式
   output: {
     filename: '[name]-[contenthash:8].bundle.js'
   },
   plugins: [..., new MiniCssExtractPlugin({ filename: '[name]-[hash:8].bundle.css' })]
   ```

   # Rollup

   ESM打包器, 功能和webpack类似, 但更为小巧, 仅仅只有打包功能, 不具有类似HMR等高级特性

   初衷是一个充分利用ESM各项特性的**高效打包器**

   ```js
   yarn add rollup --dev
   yarn rollup ./src/index.js --file dist/bundle.js --format iife // 自调用函数
   // 打包结果十分简洁, 按照模块依赖顺序拼接到一起
   // 默认开启tree shaking, 最早也是rollup提出的
   
   // rollup.config.js
   export defualt {
     input: 'src/index.js',
     output: {
       file: 'dist/bundle.js',
       format: 'iife'
   }}
   yarn rollup --ocnfig (rollup.config.js)
   ```

   ## 插件

   唯一扩展途径

   ```js
   import json from 'rollup-plugin-json'
   import resolve from 'rollup-plugin-node-resolve'
   import commonjs from 'rollup-plugin-commonjs'
   export default {
     ..., plugins: [
       json(),
       resolve(),
       commonjs(),
   ]}
   
   import { name, version } from './package.json'
   import _ from 'lodash-es' // rollup默认只支持esm的模块
   import cjk from 'cjk-module' // 使用commonjs插件导入commonjs模块
   ```

   ## 代码拆分

   ```js
   // index.js
   import('./logger').then(({ log }) => {
     log('works')
   })
   // config.js
   export default {
     input: './index.js',
     output: {
       dir: 'dist', // 拆分后会生成多个文件, 不能指定path
       format: 'amd', // 必须是支持动态导入的格式, 如amd/commonjs
   }}
   ```

   ### 多入口打包

   ```js
   input: {
     foo: './foo.js',
     bar: './bar.js'
   },
   output: {
     dir: 'dist',
     format: 'amd'
   }
   // 生成两个入口文件和1个公共模块文件, 公共模块文件名默认带8位hash
   
   // index.html
   // html使用时需要引入支持amd标准的库, 然后在引入打包文件
   <script src="https://unpkg.com/requirejs@2.3.6/require.js" data-main="foo.js"></script>
   ```

   ## 选用原则

   优点

   - 输出结果扁平
   - 自动移除未引用代码
   - 打包结果可读性强

   缺点

   - 加载非ESM比较复杂
   - 模块最终打包到一个函数, 无法实现HMR
   - 浏览器环境下, 代码拆分依赖AMD库

   rollup小而美, 适合开发框架或类库, 如vue, react

   webpack大而全, 适合开发应用

   ## parcel

   零配置的前端应用打包器, 愿景是让开发者想做什么就去做, 工具自动安装需要的插件

   2017年出现, 针对webpack的配置繁琐缺点, 构建速度更快

   - 支持esm
   - build之后自动启动服务器
   - 服务器自动刷新
   - 通过`module.hot.accept(() => { ... })`支持热更新
     - 在模块更新或依赖的模块更新后执行
   - 支持自动安装依赖
     - 在js中引入新module, 服务器自动安装, 然后刷新页面
   - 支持css等资源文件的引用和热更新
   - 支持代码分割, 动态导入

   ```js
   yarn add parcel-bundler --dev
   // u官方建议使用html作为入口文件
   ```

   - webpack生态更好
   - webpack越来越好用

   # 规范化

   - 软件开发多人协同, 不同开发者有不同编码习惯和爱好
   - 不同喜好增加维护成本, 故每个项目或团队需要明确统一的标准
   - 编码前人为约定标准, 然后通过工具实现Lint

   ## ESLint

   使用必须创建config文件`yarn eslint --init`

   `exlint --fix`自动修正风格错误

   ### [.eslintrc.js](https://cn.eslint.org/docs/user-guide/configuring)

   ```js
   module.exports = {
     env: { browser: true, es2020: true }, // 导入对应环境/语言版本的变量
     extends: { 'standard' },
     parserOptions: { ecmaVersion: 5 }, // 决定支持的ES语法, 但不会导入对应语法的变量
     rules: { 'no-alert': false }, // https://cn.eslint.org/docs/rules/
     globals: { 'jQuery': 'readonly' }
   }
   ```

   ### 配置注释

   ```js
   const template = "${name} is good" // eslint-disable-line no-template-curly-in-string
   ```

   ### 结合gulp

   ```js
   const script = () => {
     return src('*.js', { base: 'src' })
       .pipe(plugins.eslint.format())
       .pipe(plugins.selint.failAfterError())
       .pipe(plugins.babel({ presets: ['@babel/preset-env'] }))
       .pipe(dest('temp'))
   }
   ```

   ### 结合webpack

   ```js
   yarn add exlint-loader -dev
   // webpack.config.js
   rules: [{
     test: /\.js$/,
     exclude: '/nodemodules/',
     use: 'es-lint-loader',
     enforce: 'pre' // 强制前置该任务
   }]
   // .eslintrc.js
   // 对特殊框架可以使用插件规则
   plugins: ['react'], // exlint-plugin-react
   rules: { // 可以单条规则引入
     'react/jsx-uses-react': 2, // 2 === 'error'
     'react/jsx-uses-vars': 'error'
   },
   extends: [ // 也可以引入一套预定义规则
     'standard',
     'plugin:react/recommended' // 
   ]
   ```

   vue, react等现代化框架脚手架都集成了eslint等通用工具

   ### 检查typescript

   之前有tslint, 后来官方放弃维护, 建议使用eslint结合ts插件

   ```js
   // .eslintrc.js
   parser: '@typescript-eslint/parser'
   ```

   ## StyleLint

   和其他lint工具类似

   - 提供默认检查规则
   - 提供cli, 快速调用
   - 通过插件支持sass, less, postCss
   - 支持gulp webpack集成

   ```js
   yarn add stylelint-config-standard
   yarn add stylelint-config-sass-guildlines
   // .stylelintrc.js
   module.exports = {
     extends: [
       "stylelint-config-standard",
       "stylelint-config-sass-guildlines",
   ]}
   ```

   ## prettier

   可以规范格式化前端涉及到的所有文件类型, 如js, jsx, vue, css, md等

   ```js
   yarn prettier . --write // 必须--write才会写入
   ```

   ## git hooks

   ```sh
   # .git/hooks/pre-commit
   #!/bin/sh
   echo 'hello'
   ```

   ### Husky, lint-staged

   方便不熟悉sh语言的开发者实现git hooks的使用需求

   ```js
   yarn add husky --dev
   // package.json
   "scripts": {
     "precommit": "lint-staged"
   },
   "husky": {
     "hooks": {
       "pre-commit": "yarn precommit"
   }},
   "lint-staged": {
     "*.js": [
       "eslint",
       "git add"
   ]}
   ```